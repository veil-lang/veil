struct Span {
    start: int,
    end: int,
}

enum Token {
  KwFn, KwTest, KwLet, KwVar, KwIf, KwElse, KwReturn, KwRawPtr, KwDefer,
  KwAs, KwWhile, KwFor, KwStep, KwLoop, KwImport, KwFrom, KwExport,
  KwStruct, KwImpl, KwNew, KwConstructor, KwEnum, KwMatch, KwTrue,
  KwFalse, KwNone, KwIn, KwBreak, KwContinue, KwForeign,

  TyBool, TyString, TyVoid, TyAny,
  TyU8, TyU16, TyU32, TyU64,
  TyI8, TyI16, TyI32, TyI64,
  TyF32, TyF64,

  Dot, Ellipsis, Arrow, Colon, EqEq, NotEq, GtEq, LtEq,
  LParen, RParen, LBrace, RBrace, LBracket, RBracket, EmptyArray,
  Comma, Eq, Semi, Plus, Minus, Star, Slash, DoubleStar, Caret, Percent,
  Gt, Lt, DotDotEq, DotDotGt, DotDotLt, DotDot, AndAnd, OrOr, Pipe,
  Arrow2, Hash, Bang, Question,

  Ident(string),
  Str(string),
  TemplateStr(string),
  Int(string),
  F32(string),

  Eof,
  Error(string)
}

struct Lexer {
    source: string,
    pos: int,
    len: int,
    curr: int,
}

impl Lexer {
    constructor(source: string) -> Lexer {
        let n = source.length();
        let c = if n > 0 { source.at(0) } else { -1 };
        return Lexer {
            source: source,
            pos: 0,
            len: n,
            curr: c,
        };
    }

    fn advance(self) {
        self.pos = self.pos + 1;
        if self.pos >= self.len {
            self.curr = -1;
        } else {
            self.curr = self.source.at(self.pos);
        }
    }

    fn peek(self, offset: int) -> int {
        let i = self.pos + offset;
        if i < 0 || i >= self.len {
            return -1;
        }
        return self.source.at(i);
    }

    fn skip_whitespace_and_comments(self) {
        loop {
            while is_space(self.curr) {
                self.advance();
            }
            if self.curr == 47 { // '/'
                if self.peek(1) == 47 { // '//'
                    self.advance(); self.advance();
                    while self.curr != 10 && self.curr != -1 { // until '\n' or EOF
                        self.advance();
                    }
                    continue;
                } else if self.peek(1) == 42 { // '/*'
                    self.advance(); self.advance();
                    while true {
                        if self.curr == -1 { break; }
                        if self.curr == 42 && self.peek(1) == 47 { // '*/'
                            self.advance(); self.advance();
                            break;
                        }
                        self.advance();
                    }
                    continue;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    fn next_token(self) -> Token {
        self.skip_whitespace_and_comments();
        if self.curr == -1 { return Token.Eof; }
        if is_alpha(self.curr) { return self.scan_ident(); }
        if is_digit(self.curr) { return self.scan_number(); }
        if self.curr == 34 { return self.scan_string(); } // '"'
        if self.curr == 96 { return self.scan_template_string(); } // '`'
        if self.curr == 40 { self.advance(); return Token.LParen; } // '('
        if self.curr == 41 { self.advance(); return Token.RParen; } // ')'
        if self.curr == 123 { self.advance(); return Token.LBrace; } // '{'
        if self.curr == 125 { self.advance(); return Token.RBrace; } // '}'
        if self.curr == 91 { self.advance(); return Token.LBracket; } // '['
        if self.curr == 93 { self.advance(); return Token.RBracket; } // ']'
        if self.curr == 44 { self.advance(); return Token.Comma; } // ','
        if self.curr == 59 { self.advance(); return Token.Semi; } // ';'
        if self.curr == 58 { self.advance(); return Token.Colon; } // ':'
        if self.curr == 35 { self.advance(); return Token.Hash; } // '#'
        if self.curr == 63 { self.advance(); return Token.Question; } // '?'
        if self.curr == 94 { self.advance(); return Token.Caret; } // '^'
        if self.curr == 46 { // '.'
            if self.peek(1) == 46 {
                if self.peek(2) == 46 { // '...'
                    self.advance(); self.advance(); self.advance();
                    return Token.Ellipsis;
                } else if self.peek(2) == 61 { // '..='
                    self.advance(); self.advance(); self.advance();
                    return Token.DotDotEq;
                } else if self.peek(2) == 62 { // '..>'
                    self.advance(); self.advance(); self.advance();
                    return Token.DotDotGt;
                } else if self.peek(2) == 60 { // '..<'
                    self.advance(); self.advance(); self.advance();
                    return Token.DotDotLt;
                } else { // '..'
                    self.advance(); self.advance();
                    return Token.DotDot;
                }
            } else {
                self.advance();
                return Token.Dot;
            }
        }
        if self.curr == 43 { self.advance(); return Token.Plus; } // '+'
        if self.curr == 45 {
            self.advance();
            if self.curr == 62 { self.advance(); return Token.Arrow; } // '->'
            return Token.Minus; // '-'
        }
        if self.curr == 42 {
            self.advance();
            if self.curr == 42 { self.advance(); return Token.DoubleStar; } // '**'
            return Token.Star; // '*'
        }
        if self.curr == 47 { self.advance(); return Token.Slash; } // '/'
        if self.curr == 37 { self.advance(); return Token.Percent; } // '%'
        if self.curr == 61 {
            self.advance();
            if self.curr == 61 { self.advance(); return Token.EqEq; } // '=='
            if self.curr == 62 { self.advance(); return Token.Arrow2; } // '=>'
            return Token.Eq; // '='
        }
        if self.curr == 33 {
            self.advance();
            if self.curr == 61 { self.advance(); return Token.NotEq; } // '!='
            return Token.Bang; // '!'
        }
        if self.curr == 60 {
            self.advance();
            if self.curr == 61 { self.advance(); return Token.LtEq; } // '<='
            return Token.Lt; // '<'
        }
        if self.curr == 62 {
            self.advance();
            if self.curr == 61 { self.advance(); return Token.GtEq; } // '>='
            return Token.Gt; // '>'
        }
        if self.curr == 38 {
            self.advance();
            if self.curr == 38 { self.advance(); return Token.AndAnd; } // '&&'
            return Token.Error("Invalid character '&'");
        }
        if self.curr == 124 {
            self.advance();
            if self.curr == 124 { self.advance(); return Token.OrOr; } // '||'
            return Token.Pipe; // '|'
        }
        return Token.Error("Unknown character");
    }

    fn scan_ident(self) -> Token {
        let start = self.pos;
        while is_alnum(self.curr) { self.advance(); }
        let text = self.source.slice(start, self.pos);
        return keyword_or_ident(text);
    }

    fn scan_number(self) -> Token {
        let start = self.pos;
        while is_digit(self.curr) { self.advance(); }
        if self.curr == 46 && is_digit(self.peek(1)) { // '.'
            self.advance();
            while is_digit(self.curr) { self.advance(); }
            let text = self.source.slice(start, self.pos);
            return Token.F32(text);
        }
        let text = self.source.slice(start, self.pos);
        return Token.Int(text);
    }

    fn scan_string(self) -> Token {
        self.advance(); // skip opening '"'
        let start = self.pos;
        while self.curr != 34 && self.curr != -1 { // until '"' or EOF
            if self.curr == 92 { self.advance(); } // skip escape sequence
            self.advance();
        }
        if self.curr == -1 {
            return Token.Error("Unterminated string");
        }
        let text = self.source.slice(start, self.pos);
        self.advance(); // skip closing '"'
        return Token.Str(text);
    }

    fn scan_template_string(self) -> Token {
        self.advance(); // skip opening '`'
        let start = self.pos;
        while self.curr != 96 && self.curr != -1 { // until '`' or EOF
            if self.curr == 92 { self.advance(); } // skip escape sequence
            self.advance();
        }
        if self.curr == -1 {
            return Token.Error("Unterminated template string");
        }
        let text = self.source.slice(start, self.pos);
        self.advance(); // skip closing '`'
        return Token.TemplateStr(text);
    }
}

fn is_digit(c: int) -> bool {
    return c >= 48 && c <= 57;  // '0'..'9'
}

fn is_alpha(c: int) -> bool {
    return (c >= 97 && c <= 122) || (c >= 65 && c <= 90) || c == 95;  // 'a'..'z', 'A'..'Z', '_'
}

fn is_alnum(c: int) -> bool {
    return is_alpha(c) || is_digit(c);
}

fn is_space(c: int) -> bool {
    return c == 32 || c == 9 || c == 10 || c == 13;  // ' ', '\t', '\n', '\r'
}

fn keyword_or_ident(s: string) -> Token {
    if s == "fn" { return Token.KwFn; }
    if s == "test" { return Token.KwTest; }
    if s == "let" { return Token.KwLet; }
    if s == "var" { return Token.KwVar; }
    if s == "if" { return Token.KwIf; }
    if s == "else" { return Token.KwElse; }
    if s == "return" { return Token.KwReturn; }
    if s == "rawptr" { return Token.KwRawPtr; }
    if s == "defer" { return Token.KwDefer; }
    if s == "as" { return Token.KwAs; }
    if s == "while" { return Token.KwWhile; }
    if s == "for" { return Token.KwFor; }
    if s == "step" { return Token.KwStep; }
    if s == "loop" { return Token.KwLoop; }
    if s == "import" { return Token.KwImport; }
    if s == "from" { return Token.KwFrom; }
    if s == "export" { return Token.KwExport; }
    if s == "struct" { return Token.KwStruct; }
    if s == "impl" { return Token.KwImpl; }
    if s == "new" { return Token.KwNew; }
    if s == "constructor" { return Token.KwConstructor; }
    if s == "enum" { return Token.KwEnum; }
    if s == "match" { return Token.KwMatch; }
    if s == "true" { return Token.KwTrue; }
    if s == "false" { return Token.KwFalse; }
    if s == "None" { return Token.KwNone; }
    if s == "in" { return Token.KwIn; }
    if s == "break" { return Token.KwBreak; }
    if s == "continue" { return Token.KwContinue; }
    if s == "foreign" { return Token.KwForeign; }

    if s == "bool" { return Token.TyBool; }
    if s == "string" { return Token.TyString; }
    if s == "void" { return Token.TyVoid; }
    if s == "any" { return Token.TyAny; }
    if s == "u8" || s == "byte" { return Token.TyU8; }
    if s == "u16" || s == "ushort" { return Token.TyU16; }
    if s == "u32" || s == "uint" { return Token.TyU32; }
    if s == "u64" || s == "ulong" { return Token.TyU64; }
    if s == "i8" || s == "sbyte" { return Token.TyI8; }
    if s == "i16" || s == "short" { return Token.TyI16; }
    if s == "i32" || s == "int" { return Token.TyI32; }
    if s == "i64" || s == "long" { return Token.TyI64; }
    if s == "f32" || s == "float" { return Token.TyF32; }
    if s == "f64" || s == "double" { return Token.TyF64; }

    return Token.Ident(s);
}


enum Expr {
    Ident(string),
    Int(string),
    Binary { left: Expr, op: BinOp, right: Expr },
}

enum BinOp { Add, Sub, Mul, Div }

enum Stmt {
    Let(string, Expr),
    Return(Expr),
    Expr(Expr),
}

struct Parser {
    tokens: Token[],
    pos: int,
    current: Token
}

impl Parser {
    constructor(tokens: Token[]) -> Parser {
        return Parser { tokens: tokens, pos: 0, current: tokens[0] };
    }

    fn advance(self) {
        self.pos = self.pos + 1;
        if self.pos < self.tokens.length() {
            self.current = self.tokens[self.pos];
        } else {
            self.current = Token.Eof;
        }
    }

    fn parse_primary(self) -> Expr {
        match self.current {
            Token.Ident(name) => {
                self.advance();
                return Expr.Ident(name);
            }
            Token.Int(value) => {
                self.advance();
                return Expr.Int(value);
            }
            Token.LParen => {
                self.advance(); // skip '('
                let expr = self.parse_expr();
                // expect ')'
                self.advance();
                return expr;
            }
        }
    }

    fn parse_expr(self) -> Expr {
        let left = self.parse_primary();
        if self.current == Token.Plus {
            self.advance();
            let right = self.parse_expr();
            return Expr.Binary { left: left, op: BinOp.Add, right: right };
        }
        return left;
    }

}



fn token_to_string(tok: Token) -> string {
    match tok {
        Token.KwFn => "KwFn",
        Token.KwTest => "KwTest",
        Token.KwLet => "KwLet",
        Token.KwVar => "KwVar",
        Token.KwIf => "KwIf",
        Token.KwElse => "KwElse",
        Token.KwReturn => "KwReturn",
        Token.KwRawPtr => "KwRawPtr",
        Token.KwDefer => "KwDefer",
        Token.KwAs => "KwAs",
        Token.KwWhile => "KwWhile",
        Token.KwFor => "KwFor",
        Token.KwStep => "KwStep",
        Token.KwLoop => "KwLoop",
        Token.KwImport => "KwImport",
        Token.KwFrom => "KwFrom",
        Token.KwExport => "KwExport",
        Token.KwStruct => "KwStruct",
        Token.KwImpl => "KwImpl",
        Token.KwNew => "KwNew",
        Token.KwConstructor => "KwConstructor",
        Token.KwEnum => "KwEnum",
        Token.KwMatch => "KwMatch",
        Token.KwTrue => "KwTrue",
        Token.KwFalse => "KwFalse",
        Token.KwNone => "KwNone",
        Token.KwIn => "KwIn",
        Token.KwBreak => "KwBreak",
        Token.KwContinue => "KwContinue",
        Token.KwForeign => "KwForeign",

        Token.TyBool => "TyBool",
        Token.TyString => "TyString",
        Token.TyVoid => "TyVoid",
        Token.TyAny => "TyAny",
        Token.TyU8 => "TyU8",
        Token.TyU16 => "TyU16",
        Token.TyU32 => "TyU32",
        Token.TyU64 => "TyU64",
        Token.TyI8 => "TyI8",
        Token.TyI16 => "TyI16",
        Token.TyI32 => "TyI32",
        Token.TyI64 => "TyI64",
        Token.TyF32 => "TyF32",
        Token.TyF64 => "TyF64",

        Token.Dot => "Dot",
        Token.Ellipsis => "Ellipsis",
        Token.Arrow => "Arrow",
        Token.Colon => "Colon",
        Token.EqEq => "EqEq",
        Token.NotEq => "NotEq",
        Token.GtEq => "GtEq",
        Token.LtEq => "LtEq",
        Token.LParen => "LParen",
        Token.RParen => "RParen",
        Token.LBrace => "LBrace",
        Token.RBrace => "RBrace",
        Token.LBracket => "LBracket",
        Token.RBracket => "RBracket",
        Token.EmptyArray => "EmptyArray",
        Token.Comma => "Comma",
        Token.Eq => "Eq",
        Token.Semi => "Semi",
        Token.Plus => "Plus",
        Token.Minus => "Minus",
        Token.Star => "Star",
        Token.Slash => "Slash",
        Token.DoubleStar => "DoubleStar",
        Token.Caret => "Caret",
        Token.Percent => "Percent",
        Token.Gt => "Gt",
        Token.Lt => "Lt",
        Token.DotDotEq => "DotDotEq",
        Token.DotDotGt => "DotDotGt",
        Token.DotDotLt => "DotDotLt",
        Token.DotDot => "DotDot",
        Token.AndAnd => "AndAnd",
        Token.OrOr => "OrOr",
        Token.Pipe => "Pipe",
        Token.Arrow2 => "Arrow2",
        Token.Hash => "Hash",
        Token.Bang => "Bang",
        Token.Question => "Question",

        Token.Ident(name) => "Ident(" + name + ")",
        Token.Str(s) => "Str(\"" + s + "\")",
        Token.TemplateStr(s) => "TemplateStr(`" + s + "`)",
        Token.Int(v) => "Int(" + v + ")",
        Token.F32(v) => "F32(" + v + ")",

        Token.Error(msg) => "Error(" + msg + ")",
        Token.Eof => "Eof",

        _ => "OtherToken",
    }
}

fn run_on_source(src: string) {
    print("=== SOURCE ===");
    print(src);
    print("=== TOKENS ===");
    let lexer = new Lexer(src);
    loop {
        let tok = lexer.next_token();
        let s = token_to_string(tok);
        print(s);
        if tok == Token.Eof {
            break;
        }
    }
    print("=== END ===");
}

fn main() {
}