/* veil/src/codegen/ir_c/mod.rs
 *
 * Minimal IR → C emitter (scaffold for M8).
 *
 * Notes:
 * - This module emits a compilable C translation unit from a ProgramIR.
 * - It currently generates stubs for function bodies (returns default values),
 *   because the current IR does not attach result ValueIds to instructions.
 * - As HIR→IR lowering matures (with explicit SSA/value results per Inst),
 *   this emitter can map ValueIds to C temporaries and produce full bodies.
 *
 * Integration:
 * - Construct IrCBackend with CodegenConfig and call write_to_path(&ProgramIR, &Path).
 * - The CLI can then compile the generated C file as usual.
 */

use std::fmt::Write as _;
use std::path::Path;

use crate::codegen::CodegenConfig;
use veil_ir::{ProgramIR, TypeIR};

/// Minimal IR→C backend
pub struct IrCBackend {
    pub config: CodegenConfig,
}

impl IrCBackend {
    pub fn new(config: CodegenConfig) -> Self {
        Self { config }
    }

    /// Render IR into a self-contained C translation unit as a String.
    pub fn emit_to_string(&self, ir: &ProgramIR) -> String {
        let mut out = String::new();

        // Preamble and includes
        out.push_str("/* Generated by Veil IR→C backend (minimal) */\n");
        out.push_str("#include <stdint.h>\n");
        out.push_str("#include <stdbool.h>\n");
        out.push_str("#include <stddef.h>\n");
        out.push_str("#include <stdio.h>\n");
        out.push_str("#include <string.h>\n\n");

        // Forward declare functions (sorted deterministically by name)
        let mut fns = ir.functions.clone();
        fns.sort_by(|a, b| a.name.cmp(&b.name));
        for f in &fns {
            let sig = self.function_signature(
                f.name.as_str(),
                &f.params.iter().map(|p| p.ty.clone()).collect::<Vec<_>>(),
                &f.ret,
            );
            out.push_str(&sig);
            out.push_str(";\n");
        }
        out.push_str("\n");

        // Definitions
        for f in &fns {
            let sig = self.function_signature(
                f.name.as_str(),
                &f.params.iter().map(|p| p.ty.clone()).collect::<Vec<_>>(),
                &f.ret,
            );
            out.push_str(&sig);
            out.push_str(" {\n");
            // Declare function-local slots (IR locals) up-front with deterministic names
            for l in &f.locals {
                let cty = self.type_to_c(&l.ty);
                let _ = writeln!(out, "    {} l{};", cty, l.id.0);
            }

            // Emit parameter names
            // In C, parameters are already named in the signature.

            // Emit IR blocks and instructions with simple typing:
            // - int64_t for integer arithmetic and generic numeric ops
            // - double for floating constants
            // - bool for comparisons
            // - const char* for strings
            // - call return type inferred by scanning declared function prototypes (fallback int64_t)
            let mut declared: std::collections::BTreeSet<u32> = std::collections::BTreeSet::new();

            let val_ref = |id: veil_ir::ValueId| -> String {
                if (id.0 as usize) < f.params.len() {
                    format!("p{}", id.0)
                } else {
                    format!("v{}", id.0)
                }
            };

            let mut declare_or_assign =
                |id: veil_ir::ValueId, cty: &str, rhs: &str, out: &mut String| {
                    let name = if (id.0 as usize) < f.params.len() {
                        format!("p{}", id.0)
                    } else {
                        format!("v{}", id.0)
                    };
                    if declared.insert(id.0) && (id.0 as usize) >= f.params.len() {
                        let _ = writeln!(out, "    {} {} = {};", cty, name, rhs);
                    } else {
                        let _ = writeln!(out, "    {} = {};", name, rhs);
                    }
                };

            let escape_c_str =
                |s: &str| -> String { s.replace("\\", "\\\\").replace("\"", "\\\"") };

            // Helper to obtain C type of a local slot
            let local_cty = |lid: veil_ir::LocalId| -> String {
                if let Some(loc) = f.locals.iter().find(|ll| ll.id == lid) {
                    self.type_to_c(&loc.ty)
                } else {
                    "int64_t".to_string()
                }
            };

            // Emit labeled basic blocks in id order
            let mut blocks = f.blocks.clone();
            blocks.sort_by_key(|b| b.id);

            for b in blocks {
                let _ = writeln!(out, "bb{}:", b.id.0);

                for (i, inst) in b.insts.iter().enumerate() {
                    let res = b.results.get(i).copied().unwrap_or(veil_ir::ValueId(0));
                    match inst {
                        veil_ir::InstIR::Nop => {
                            declare_or_assign(res, "int64_t", "0", &mut out);
                        }
                        veil_ir::InstIR::ConstInt { value } => {
                            declare_or_assign(res, "int64_t", &format!("{}", value), &mut out);
                        }
                        veil_ir::InstIR::ConstFloat { value } => {
                            declare_or_assign(res, "double", &format!("{}", value), &mut out);
                        }
                        veil_ir::InstIR::ConstStr { value } => {
                            let esc = escape_c_str(value);
                            declare_or_assign(
                                res,
                                "const char*",
                                &format!("\"{}\"", esc),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Add { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} + {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Sub { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} - {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Mul { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} * {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Div { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} / {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpEq { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} == {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpNe { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} != {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpLt { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} < {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpLe { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} <= {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpGt { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} > {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpGe { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} >= {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Select {
                            cond,
                            then_v,
                            else_v,
                        } => {
                            // Ternary expression lowering; target type is bool for logical selects
                            let expr = format!(
                                "({} ? {} : {})",
                                val_ref(*cond),
                                val_ref(*then_v),
                                val_ref(*else_v)
                            );
                            declare_or_assign(res, "bool", &expr, &mut out);
                        }
                        veil_ir::InstIR::Load { local } => {
                            // Load from local slot into a new SSA value
                            let rhs = format!("l{}", local.0);
                            let cty = local_cty(*local);
                            declare_or_assign(res, &cty, &rhs, &mut out);
                        }
                        veil_ir::InstIR::Store { local, value } => {
                            // Store SSA value into a local slot
                            let _ = writeln!(out, "    l{} = {};", local.0, val_ref(*value));
                        }
                        veil_ir::InstIR::Call { callee, args } => {
                            // Determine return C type by scanning prototypes
                            let mut ret_c = "int64_t".to_string();
                            for ff in &fns {
                                if ff.name == *callee {
                                    ret_c = self.type_to_c(&ff.ret);
                                    break;
                                }
                            }
                            let argv = args
                                .iter()
                                .map(|a| val_ref(*a))
                                .collect::<Vec<_>>()
                                .join(", ");
                            declare_or_assign(
                                res,
                                &ret_c,
                                &format!("{}({})", callee, argv),
                                &mut out,
                            );
                        }
                    }
                }

                // Terminator handling
                match &b.term {
                    veil_ir::TerminatorIR::Return { value } => {
                        if let Some(v) = value {
                            let _ = writeln!(out, "    return {};", val_ref(*v));
                        } else {
                            out.push_str("    return;\n");
                        }
                    }
                    veil_ir::TerminatorIR::Branch {
                        cond,
                        then_bb,
                        else_bb,
                    } => {
                        let _ = writeln!(
                            out,
                            "    if ({}) goto bb{}; else goto bb{};",
                            val_ref(*cond),
                            then_bb.0,
                            else_bb.0
                        );
                    }
                    veil_ir::TerminatorIR::Jump { bb } => {
                        let _ = writeln!(out, "    goto bb{};", bb.0);
                    }
                }

                out.push_str("\n");
            }

            out.push_str("}\n\n");
        }

        out
    }

    /// Write the generated translation unit to a path (e.g., build/temp.c)
    pub fn write_to_path(&self, ir: &ProgramIR, path: &Path) -> std::io::Result<()> {
        let c_src = self.emit_to_string(ir);
        std::fs::write(path, c_src)
    }

    // ------------------------
    // Helpers
    // ------------------------

    fn function_signature(&self, name: &str, param_tys: &[TypeIR], ret: &TypeIR) -> String {
        let mut s = String::new();

        // Return type
        s.push_str(&self.type_to_c(ret));
        s.push(' ');

        // Name
        s.push_str(name);
        s.push('(');

        // Parameters: name them p0, p1, ... deterministically
        for (i, ty) in param_tys.iter().enumerate() {
            if i > 0 {
                s.push_str(", ");
            }
            let cname = self.type_to_c(ty);
            let _ = write!(s, "{} p{}", cname, i);
        }

        if param_tys.is_empty() {
            s.push_str("void");
        }

        s.push(')');
        s
    }

    fn type_to_c(&self, ty: &TypeIR) -> String {
        use TypeIR::*;
        match ty {
            Void => "void".to_string(),
            I32 => "int".to_string(),
            I64 => "int64_t".to_string(),
            F32 => "float".to_string(),
            F64 => "double".to_string(),
            Bool => "bool".to_string(),
            String => "const char*".to_string(),
            Ptr(inner) => format!("{}*", self.type_to_c(inner)),
            Opaque(name) => {
                // Use void* for now. If this is a known struct name, one could map to a typedef.
                if name.starts_with("ve_") {
                    // Some future IR may carry canonical names. Keep simple for now.
                    "void*".to_string()
                } else {
                    "void*".to_string()
                }
            }
        }
    }

    fn default_value_for_type(&self, ty: &TypeIR) -> &'static str {
        use TypeIR::*;
        match ty {
            Void => "",
            I32 | I64 | F32 | F64 => "0",
            Bool => "false",
            String => "\"\"",
            Ptr(_) | Opaque(_) => "NULL",
        }
    }
}
