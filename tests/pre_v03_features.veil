/# Integration test for pre-v0.3 features
/# Tests increment/decrement operators and prelude injection

fn test_increment_operators() -> void {
    let x = 5;
    let y = 10;

    /# Test prefix increment
    let a = ++x;
    assert(a == 6, "Prefix increment should work");

    /# Test postfix increment
    let b = y++;
    assert(b == 10, "Postfix increment should return original value");
    assert(y == 11, "Variable should be incremented");

    /# Test prefix decrement
    let c = --x;
    assert(c == 5, "Prefix decrement should work");

    /# Test postfix decrement
    let d = y--;
    assert(d == 11, "Postfix decrement should return original value");
    assert(y == 10, "Variable should be decremented");
}

fn test_division_operators() -> void {
    let a = 7;
    let b = 3;

    /# Test integer division
    let result = a // b;
    assert(result == 2, "Integer division should work");

    /# Test float division
    let x = 7.0;
    let y = 3.0;
    let float_result = x / y;
    assert(float_result > 2.3 && float_result < 2.4, "Float division should work");
}

fn test_prelude_functions() -> void {
    /# These functions should be available due to auto-prelude injection

    /# Test abs function
    let negative = -5;
    let positive = abs(negative);
    assert(positive == 5, "abs function should work");

    /# Test max function
    let bigger = max(10, 5);
    assert(bigger == 10, "max function should work");

    /# Test min function
    let smaller = min(10, 5);
    assert(smaller == 5, "min function should work");
}

fn test_complex_increment_expressions() -> void {
    let arr = [1, 2, 3, 4, 5];
    let i = 0;

    /# Test increment in array access
    let value1 = arr[i++];
    assert(value1 == 1, "Should get first element");
    assert(i == 1, "Index should be incremented");

    /# Test increment in arithmetic
    let result = ++i + i--;
    /# i starts at 1, becomes 2, then 2 + 2 = 4, then i becomes 1
    assert(result == 4, "Complex increment expression should work");
    assert(i == 1, "Final index should be correct");
}

struct Counter {
    value: i32,
}

fn test_increment_with_field_access() -> void {
    let counter = Counter { value: 0 };

    /# Test increment on struct field
    counter.value++;
    assert(counter.value == 1, "Field increment should work");

    let old_value = counter.value++;
    assert(old_value == 1, "Should return old value");
    assert(counter.value == 2, "Field should be incremented");

    ++counter.value;
    assert(counter.value == 3, "Prefix increment on field should work");
}

fn main() -> void {
    test_increment_operators();
    test_division_operators();
    test_prelude_functions();
    test_complex_increment_expressions();
    test_increment_with_field_access();

    print("All pre-v0.3 feature tests passed!");
}
