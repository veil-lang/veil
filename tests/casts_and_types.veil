/# Casts and primitive type annotations #/

test simple_as_casts {
    let i = 1 as i32;
    let j = 2 as i32;

    /# Upcast to wider int, then to float #/
    let sum64 = (i + j) as i64;
    let f = 3.25 as f64;

    /# Back to i32 for a combined sink value #/
    let sink = (sum64 as i32) + (f as i32);
    let _ = sink;
    return;
}

test primitive_type_annotations_strict_match {
    let a: i32 = 42;
    let b: f64 = 1.5;
    let c: bool = true;
    let d: string = "veil";
    let e: str = "lang";

    /# Exercise equality and simple arithmetic in typed context #/
    let _ = (a == 42) & c;
    let _ = b + 2.5;
    let _ = d;
    let _ = e;
    return;
}

test chained_casts_roundtrip {
    let x = 7 as i32;

    /# i32 -> i64 -> f64 -> i32 #/
    let y = ((x as i64) as f64) as i32;

    /# Use y so the chain is not optimized away #/
    let _ = y + 1 as i32;
    return;
}

test mixed_casts_in_expressions {
    let i = 10 as i32;
    let f = 2.5 as f64;

    /# Mix arithmetic with explicit casts #/
    let r = (i as f64) / f + 3.0;
    let back = r as i32;

    let _ = back;
    return;
}
