//
// Tests: struct generics monomorphization (methods, static constructor, nested generics)
//

// ====== Assertions ======
fn assert_true(cond: bool) -> void {
    if !cond {
        println("assert_true failed");
        panic("assert failed");
    }
}

fn assert_eq_i32(a: i32, b: i32) -> void {
    if a != b {
        println(`assert_eq_i32 failed: ${a} != ${b}`);
        panic("assert failed");
    }
}

fn assert_eq_string(a: string, b: string) -> void {
    if a != b {
        println(`assert_eq_string failed: "${a}" != "${b}"`);
        panic("assert failed");
    }
}

// ====== Generic Struct: Box<T> ======
// - get(self) -> T
// - set(self, v: T) -> Box<T>
// - constructor(v: T) -> Box<T>
struct Box<T> {
    value: T,
}

impl Box<T> {
    constructor(v: T) -> Box<T> {
        return Box { value: v };
    }

    fn get(self) -> T {
        return self.value;
    }

    fn set(self, v: T) -> Box<T> {
        return Box { value: v };
    }
}

// ====== Generic Struct: Phantom<T> ======
// Purposefully does not store T in fields (avoids nested-by-value C ordering).
// Lets us exercise nested generics in return/param positions and impl specialization.
struct Phantom<T> {
    id: i32,
}

impl Phantom<T> {
    constructor(t: T) -> Phantom<T> {
        // Ignore 't', just build a tagged value
        return Phantom { id: 0 as i32 };
    }

    fn id(self) -> i32 {
        return self.id;
    }
}

// ====== Tests ======

test generic_struct_method_returns_T_and_takes_self {
    // i32 instance
    let bi = Box.constructor(42 as i32);
    assert_eq_i32(bi.get(), 42 as i32);

    // string instance
    let bs = Box.constructor("hello");
    assert_eq_string(bs.get(), "hello");
}

test static_constructor_returns_self_T_and_chaining {
    let b1 = Box.constructor(1 as i32);
    let b2 = b1.set(2 as i32);
    assert_eq_i32(b2.get(), 2 as i32);

    let s1 = Box.constructor("a");
    let s2 = s1.set("z");
    assert_eq_string(s2.get(), "z");
}

test nested_generics_phantom_over_box_i32 {
    let bi = Box.constructor(5 as i32);          // Box<i32>
    let pb = Phantom.constructor(bi);            // Phantom<Box<i32>>
    assert_eq_i32(pb.id(), 0 as i32);
}

test nested_generics_double_phantom_i32 {
    let pi = Phantom.constructor(123 as i32);    // Phantom<i32>
    let ppi = Phantom.constructor(pi);           // Phantom<Phantom<i32>>
    assert_eq_i32(ppi.id(), 0 as i32);
}

test nested_generics_phantom_over_string_box {
    let bs = Box.constructor("x");               // Box<string>
    let ps = Phantom.constructor(bs);            // Phantom<Box<string>>
    assert_eq_i32(ps.id(), 0 as i32);
}
