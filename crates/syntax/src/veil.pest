WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

COMMENT      = _{ LINE_COMMENT | BLOCK_COMMENT }
LINE_COMMENT = _{ "/#" ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) }
BLOCK_COMMENT= _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

S = _{ (WHITESPACE | COMMENT)* }
WS = _{ WHITESPACE* }

ident_continue = _{ ASCII_ALPHANUMERIC | "_" }
ident = @{ !KEYWORD ~ (ASCII_ALPHA | "_") ~ ident_continue* }

hex_prefix = @{ "0x" }
bin_prefix = @{ "0b" }

int_lit = @{
    hex_prefix ~ ASCII_HEX_DIGIT+ |
    bin_prefix ~ ("0" | "1")+ |
    ASCII_DIGIT+
}

float_lit = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

dq_string_inner = { "\\\"" | !"\"" ~ ANY }
str_lit = @{ "\"" ~ dq_string_inner* ~ "\"" }

bt_string_chunk = { "\\`" | !("`" | "{") ~ ANY }
template_interpolation = { "{" ~ S ~ expr ~ S ~ "}" }
template_str = @{ "`" ~ (bt_string_chunk | template_interpolation)* ~ "`" }

bool_lit = _{ "true" | "false" }
none_lit = _{ "None" | "none" }

module_path = @{ ident ~ ( ( "::" | "/" ) ~ ident )* }  // Accept both '::' and '/' separators

// Keywords (kept as rules for clarity; identifiers are separate)
KW_FN          = @{ "fn" ~ !ident_continue }
KW_TEST        = @{ "test" ~ !ident_continue }
KW_LET         = @{ "let" ~ !ident_continue }
KW_VAR         = @{ "var" ~ !ident_continue }
KW_CONST       = @{ "const" ~ !ident_continue }
KW_IF          = @{ "if" ~ !ident_continue }
KW_ELSE        = @{ "else" ~ !ident_continue }
KW_RETURN      = @{ "return" ~ !ident_continue }
KW_DEFER       = @{ "defer" ~ !ident_continue }
KW_SAFE        = @{ "safe" ~ !ident_continue }
KW_AS          = @{ "as" ~ !ident_continue }
KW_WHILE       = @{ "while" ~ !ident_continue }
KW_FOR         = @{ "for" ~ !ident_continue }
KW_IN          = @{ "in" ~ !ident_continue }
KW_STEP        = @{ "step" ~ !ident_continue }
KW_LOOP        = @{ "loop" ~ !ident_continue }
KW_IMPORT      = @{ "import" ~ !ident_continue }
KW_FROM        = @{ "from" ~ !ident_continue }
KW_EXPORT      = @{ "export" ~ !ident_continue }
KW_STRUCT      = @{ "struct" ~ !ident_continue }
KW_ENUM        = @{ "enum" ~ !ident_continue }
KW_UNION       = @{ "union" ~ !ident_continue }
KW_TRAIT       = @{ "trait" ~ !ident_continue }
KW_IMPL        = @{ "impl" ~ !ident_continue }
KW_NEW         = @{ "new" ~ !ident_continue }
KW_CONSTRUCTOR = @{ "constructor" ~ !ident_continue }
KW_MATCH       = @{ "match" ~ !ident_continue }
KW_TRUE        = @{ "true" ~ !ident_continue }
KW_FALSE       = @{ "false" ~ !ident_continue }
KW_RAWPTR      = @{ "rawptr" ~ !ident_continue }
KW_FOREIGN     = @{ "foreign" ~ !ident_continue }
KW_TYPE        = @{ "type" ~ !ident_continue }
KW_PUB         = @{ "pub" ~ !ident_continue }
KW_ASYNC       = @{ "async" ~ !ident_continue }
KW_AWAIT       = @{ "await" ~ !ident_continue }

KEYWORD = _{
    KW_FN | KW_TEST | KW_LET | KW_VAR | KW_CONST | KW_IF | KW_ELSE | KW_RETURN | KW_DEFER | KW_SAFE | KW_AS
  | KW_WHILE | KW_FOR | KW_IN | KW_STEP | KW_LOOP | KW_IMPORT | KW_FROM | KW_EXPORT | KW_STRUCT | KW_ENUM
  | KW_UNION | KW_TRAIT | KW_IMPL | KW_NEW | KW_CONSTRUCTOR | KW_MATCH | KW_TRUE | KW_FALSE | KW_RAWPTR
  | KW_FOREIGN | KW_TYPE | KW_PUB | KW_ASYNC | KW_AWAIT
  | TY_BOOL | TY_STRING | TY_STR | TY_VOID | TY_ANY | TY_U8A | TY_U8B | TY_U16A | TY_U16B | TY_U32A | TY_U32B | TY_U64A | TY_U64B
  | TY_I8A | TY_I8B | TY_I16A | TY_I16B | TY_I32A | TY_I32B | TY_I64A | TY_I64B | TY_F32A | TY_F32B | TY_F64A | TY_F64B
  | none_lit
}

// Primitive types (aligns with implementation)
TY_BOOL   = @{ "bool" ~ !ident_continue }
TY_STRING = @{ "string" ~ !ident_continue }
TY_STR    = @{ "str" ~ !ident_continue }
TY_VOID   = @{ "void" ~ !ident_continue }
TY_ANY    = @{ "any" ~ !ident_continue }

TY_U8A  = @{ "byte" ~ !ident_continue }
TY_U8B  = @{ "u8" ~ !ident_continue }
TY_U16A = @{ "ushort" ~ !ident_continue }
TY_U16B = @{ "u16" ~ !ident_continue }
TY_U32A = @{ "uint" ~ !ident_continue }
TY_U32B = @{ "u32" ~ !ident_continue }
TY_U64A = @{ "ulong" ~ !ident_continue }
TY_U64B = @{ "u64" ~ !ident_continue }

TY_I8A  = @{ "sbyte" ~ !ident_continue }
TY_I8B  = @{ "i8" ~ !ident_continue }
TY_I16A = @{ "short" ~ !ident_continue }
TY_I16B = @{ "i16" ~ !ident_continue }
TY_I32A = @{ "int" ~ !ident_continue }
TY_I32B = @{ "i32" ~ !ident_continue }
TY_I64A = @{ "long" ~ !ident_continue }
TY_I64B = @{ "i64" ~ !ident_continue }

TY_F32A = @{ "float" ~ !ident_continue }
TY_F32B = @{ "f32" ~ !ident_continue }
TY_F64A = @{ "double" ~ !ident_continue }
TY_F64B = @{ "f64" ~ !ident_continue }

// Multi-char operators and tokens
ELLIPSIS   = { "..." }
POW        = { "**" }
INC        = { "++" }
DEC        = { "--" }
ARROW      = { "->" }
FATARROW   = { "=>" }
EQEQ       = { "==" }
NOTEQ      = { "!=" }
GTE        = { ">=" }
LTE        = { "<=" }
ANDAND     = { "&&" }  // DEPRECATED: Use & for logical AND
OROR       = { "||" }  // DEPRECATED: Use | for logical OR
SHL        = { "<<" }
SHR        = { ">>" }
IDIV       = { "//" }
RANGE_EQ   = { "..=" }
RANGE_GT   = { "..>" }
RANGE_LT   = { "..<" }
RANGE      = { ".." }

PLUSEQ     = { "+=" }
MINUSEQ    = { "-=" }
MULEQ      = { "*=" }
DIVEQ      = { "/=" }
IDIVEQ     = { "//=" }
MODEQ      = { "%=" }
POWEQ      = { "**=" }
SHLEQ      = { "<<=" }
SHREQ      = { ">>=" }
ANDEQ      = { "&=" }
XOREQ      = { "^=" }
OREQ       = { "|=" }

LPAREN = { "(" }
RPAREN = { ")" }
LBRACE = { "{" }
RBRACE = { "}" }
LBRACK = { "[" }
RBRACK = { "]" }
COMMA  = { "," }
SEMI   = { ";" }
COLON  = { ":" }
DOT    = { "." }
EQ     = { "=" }
PLUS   = { "+" }
MINUS  = { "-" }
STAR   = { "*" }
SLASH  = { "/" }
BANG   = { "!" }
PERCENT= { "%" }
CARET  = { "^" }
AMP    = { "&" }
PIPE   = { "|" }
GT     = { ">" }
LT     = { "<" }
QUESTION = { "?" }
HASH     = { "#" }

// Top-level entry
token = {
    KW_FN | KW_TEST | KW_LET | KW_VAR | KW_CONST | KW_IF | KW_ELSE | KW_RETURN | KW_DEFER | KW_SAFE | KW_AS
  | KW_WHILE | KW_FOR | KW_IN | KW_STEP | KW_LOOP | KW_IMPORT | KW_FROM | KW_EXPORT | KW_STRUCT | KW_ENUM
  | KW_UNION | KW_TRAIT | KW_IMPL | KW_NEW | KW_CONSTRUCTOR | KW_MATCH | KW_TRUE | KW_FALSE | KW_RAWPTR
  | KW_FOREIGN | KW_TYPE | KW_PUB | KW_ASYNC | KW_AWAIT
  | TY_BOOL | TY_STRING | TY_STR | TY_VOID | TY_ANY | TY_U8A | TY_U8B | TY_U16A | TY_U16B | TY_U32A | TY_U32B | TY_U64A | TY_U64B
  | TY_I8A | TY_I8B | TY_I16A | TY_I16B | TY_I32A | TY_I32B | TY_I64A | TY_I64B | TY_F32A | TY_F32B | TY_F64A | TY_F64B
  | ELLIPSIS | POW | INC | DEC | ARROW | FATARROW | EQEQ | NOTEQ | GTE | LTE | ANDAND | OROR | SHL | SHR | IDIV
  | RANGE_EQ | RANGE_GT | RANGE_LT | RANGE
  | PLUSEQ | MINUSEQ | MULEQ | IDIVEQ | DIVEQ | MODEQ | POWEQ | SHLEQ | SHREQ | ANDEQ | XOREQ | OREQ
  | LPAREN | RPAREN | LBRACE | RBRACE | LBRACK | RBRACK | COMMA | SEMI | COLON | DOT | EQ | PLUS | MINUS
  | STAR | SLASH | BANG | PERCENT | CARET | AMP | PIPE | GT | LT | QUESTION | HASH
  | bool_lit | none_lit | int_lit | float_lit | str_lit | template_str | ident
}
tokens = { SOI ~ (WHITESPACE | COMMENT | token)* ~ EOI }
program = { S ~ item* ~ S ~ EOI }

item = _{
      import_decl
    | export_decl
    | export_import_decl
    | type_alias
    | function_decl
    | struct_decl
    | enum_decl
    | union_decl
    | trait_decl
    | impl_block
    | ffi_decl
    | test_decl
    | const_decl
    | var_decl
    | stmt_guarded
}

// Guard statements from starting at declaration keywords to reduce backtracking
stmt_guarded = _{
    !KW_FN
  ~ !KW_IMPORT
  ~ !KW_EXPORT
  ~ !KW_TYPE
  ~ !KW_STRUCT
  ~ !KW_ENUM
  ~ !KW_UNION
  ~ !KW_TRAIT
  ~ !KW_IMPL
  ~ !KW_TEST
  ~ !KW_FOREIGN
  ~ !KW_PUB
  ~ !KW_ASYNC
  ~ stmt
}

// Visibility
visibility = {
    KW_PUB ~ ( S ~ LPAREN ~ S ~ ( "crate" | "super" | ("in" ~ S ~ module_path) ) ~ S ~ RPAREN )?
}

// Imports / Exports
import_decl = {
    KW_IMPORT ~ S? ~ (
        module_path ~ ( S? ~ "as" ~ S? ~ ident )?
      | LBRACE ~ S? ~ import_list ~ S? ~ RBRACE ~ S? ~ KW_FROM ~ S? ~ module_path
    ) ~ S? ~ SEMI
}

const_decl = {
    attribute* ~ S ~ visibility? ~ S ~ KW_CONST ~ S ~ ident ~ S ~ COLON ~ S ~ ty ~ S ~ EQ ~ S ~ expr ~ S ~ SEMI
}

var_decl = {
    attribute* ~ S ~ visibility? ~ S ~ KW_VAR ~ S ~ ident ~ S ~ ( COLON ~ S ~ ty )? ~ S ~ ( EQ ~ S ~ expr )? ~ S ~ SEMI
}

export_decl = {
    KW_EXPORT ~ S ~ (
        function_decl
      | struct_decl
      | enum_decl
      | type_alias
      | block_export
    )
}

block_export = { LBRACE ~ S ~ (function_decl | struct_decl) ~ ( S ~ COMMA ~ S ~ (function_decl | struct_decl) )* ~ S ~ RBRACE }

export_import_decl = {
    KW_EXPORT ~ S ~ KW_IMPORT ~ S ~ (
        STAR ~ S ~ KW_FROM ~ S ~ module_path
      | LBRACE ~ S ~ import_list ~ S ~ RBRACE ~ S ~ KW_FROM ~ S ~ module_path
      | module_path ~ ( S ~ "as" ~ S ~ ident )?
    ) ~ S ~ SEMI
}

import_list = { import_item ~ ( S? ~ COMMA ~ S? ~ import_item )* }
import_item = { ident ~ ( S ~ "as" ~ S ~ ident )? }

// Type alias
type_alias = { KW_TYPE ~ S ~ ident ~ S ~ generic_params? ~ S ~ EQ ~ S ~ ty ~ S ~ SEMI }

// Declarations
function_decl_min = {
    KW_FN ~ S? ~ ident ~ S? ~ generic_params? ~ S? ~ parameter_list ~ S? ~ ( ARROW ~ S? ~ ty )? ~ S? ~ where_clause? ~ S? ~ ( block | SEMI )
}
function_decl = {
    attribute* ~ S? ~ visibility? ~ S? ~ KW_ASYNC? ~ S? ~ function_decl_min
}

// Debug-only: Minimal function head to isolate name and empty params
fn_head = {
    KW_FN ~ S? ~ ident ~ S? ~ LPAREN ~ S? ~ RPAREN
}

// Debug-only: Minimal function core to isolate header + block parsing
fn_core = {
    KW_FN ~ S? ~ ident ~ S? ~ parameter_list ~ S? ~ block
}

struct_decl = {
    attribute* ~ S ~ visibility? ~ S ~ KW_STRUCT ~ S ~ ident ~ S ~ generic_params? ~ S ~ where_clause? ~ S ~ (
        LBRACE ~ S ~ struct_fields? ~ S ~ RBRACE
      | LPAREN ~ S ~ tuple_fields? ~ S ~ RPAREN ~ S ~ SEMI
      | SEMI
    )
}

struct_fields = { struct_field ~ ( S ~ COMMA ~ S ~ struct_field )* ~ ( S ~ COMMA )? }
struct_field  = { attribute* ~ S ~ visibility? ~ S ~ ident ~ S ~ COLON ~ S ~ ty }
tuple_fields  = { attribute* ~ S ~ ty ~ ( S ~ COMMA ~ S ~ attribute* ~ S ~ ty )* }

enum_decl = {
    attribute* ~ S ~ visibility? ~ S ~ KW_ENUM ~ S ~ ident ~ S ~ generic_params? ~ S ~ where_clause? ~ S ~
    LBRACE ~ S ~ enum_variants? ~ S ~ RBRACE
}

enum_variants = { enum_variant ~ ( S ~ COMMA ~ S ~ enum_variant )* ~ ( S ~ COMMA )? }
enum_variant  = { ident ~ S ~ enum_data? ~ S ~ ( EQ ~ S ~ expr )? }
enum_data     = {
    tuple_enum_data | struct_enum_data
}
tuple_enum_data = { LPAREN ~ S ~ ( ty ~ ( S ~ COMMA ~ S ~ ty )* )? ~ S ~ RPAREN }
struct_enum_data = { LBRACE ~ S ~ struct_fields? ~ S ~ RBRACE }

union_decl = {
    attribute* ~ S ~ visibility? ~ S ~ KW_UNION ~ S ~ ident ~ S ~ generic_params? ~ S ~ where_clause? ~ S ~
    LBRACE ~ S ~ struct_fields? ~ S ~ RBRACE
}

trait_decl = {
    attribute* ~ S ~ visibility? ~ S ~ KW_TRAIT ~ S ~ ident ~ S ~ generic_params? ~ S ~ ( COLON ~ S ~ trait_bounds )? ~ S ~ where_clause? ~ S ~
    LBRACE ~ S ~ trait_item* ~ S ~ RBRACE
}

trait_item = {
      KW_FN ~ S ~ ident ~ S ~ generic_params? ~ S ~ parameter_list ~ S ~ ( ARROW ~ S ~ ty )? ~ S ~ where_clause? ~ S ~ ( block | SEMI )
    | "type" ~ S ~ ident ~ S ~ ( COLON ~ S ~ trait_bounds )? ~ S ~ SEMI
    | "const" ~ S ~ ident ~ S ~ COLON ~ S ~ ty ~ S ~ SEMI
}

impl_block = {
    KW_IMPL ~ S ~ generic_params? ~ S ~ ( ty | ( trait_bounds ~ S ~ "for" ~ S ~ ty ) ) ~ S ~ where_clause? ~ S ~
    LBRACE ~ S ~ impl_item* ~ S ~ RBRACE
}

impl_item = {
      function_decl
    | constructor_decl
}

constructor_decl = {
    KW_CONSTRUCTOR ~ S ~ parameter_list ~ S ~ block
}

test_decl = {
    KW_TEST ~ S ~ ident ~ S ~ block
}

// Attributes and metadata
attribute = { HASH ~ S ~ LBRACK ~ S ~ ident ~ ( S ~ LPAREN ~ S ~ literal ~ ( S ~ COMMA ~ S ~ literal )* ~ S ~ RPAREN )? ~ S ~ RBRACK }

// FFI
ffi_decl = {
    (metadata? ~ S ~ KW_FOREIGN ~ S ~ ffi_block) |
    (metadata? ~ S ~ KW_FOREIGN ~ S ~ ffi_item ~ S ~ SEMI)
}

ffi_block = { LBRACE ~ S ~ (ffi_item ~ S ~ SEMI)* ~ S ~ RBRACE }

ffi_item = {
      KW_FN ~ S ~ ident ~ S ~ parameter_list ~ S ~ ( ARROW ~ S ~ ty )?
    | KW_VAR ~ S ~ ident ~ S ~ COLON ~ S ~ ty
}

metadata = {
    HASH ~ S ~ LBRACE ~ S ~ metadata_kv? ~ S ~ RBRACE
}
metadata_kv = { metadata_kv_pair ~ ( S ~ COMMA ~ S ~ metadata_kv_pair )* }
metadata_kv_pair = { ident ~ S ~ COLON ~ S ~ literal }

// Parameters / Generics / Where
parameter_list = { LPAREN ~ S? ~ ( parameter ~ ( S? ~ COMMA ~ S? ~ parameter )* )? ~ S? ~ RPAREN }
parameter = { (ELLIPSIS ~ S)? ~ ident ~ S ~ COLON ~ S ~ ty }

generic_params = { LT ~ S ~ ( generic_param ~ ( S ~ COMMA ~ S ~ generic_param )* )? ~ S ~ GT }
generic_param  = { ident ~ S ~ ( COLON ~ S ~ trait_bounds )? }

generic_args = { LT ~ S ~ ( ty ~ ( S ~ COMMA ~ S ~ ty )* )? ~ S ~ GT }

where_clause = { "where" ~ S ~ where_pred ~ ( S ~ COMMA ~ S ~ where_pred )* }
where_pred = { ty ~ S ~ COLON ~ S ~ trait_bounds }

trait_bounds = { ty_path ~ ( S ~ "+" ~ S ~ ty_path )* }

// Statements
stmt = _{
      let_stmt
    | var_stmt
    | return_stmt
    | defer_stmt
    | while_stmt
    | for_stmt
    | loop_stmt
    | break_stmt
    | continue_stmt
    | if_stmt
    | block
    | expr_stmt
    | match_expr_stmt
}

block = { LBRACE ~ S? ~ ( stmt ~ S? )* ~ RBRACE }

let_stmt = {
    KW_LET ~ S ~ ident ~ ( S? ~ COLON ~ S? ~ ty )? ~ S? ~ EQ ~ S? ~ expr ~ WS? ~ SEMI
}
var_stmt = {
    KW_VAR ~ S ~ ident ~ ( S ~ COLON ~ S ~ ty )? ~ S ~ EQ ~ S ~ expr ~ WS? ~ SEMI
}

return_stmt = { KW_RETURN ~ ( S ~ expr )? ~ WS? ~ SEMI }
defer_stmt  = { KW_DEFER ~ S ~ expr ~ WS? ~ SEMI }

while_stmt = {
    KW_WHILE ~ S ~ expr ~ S ~ block
}

for_stmt = {
    KW_FOR ~ S ~ ( pattern_list | ident_list ) ~ S ~ KW_IN ~ S ~ expr ~ ( S ~ KW_STEP ~ S ~ expr )? ~ S ~ block
}

loop_stmt = { KW_LOOP ~ S ~ block }

break_stmt = { "break" ~ ( S ~ expr )? ~ S ~ SEMI }
continue_stmt = { "continue" ~ S ~ SEMI }

if_stmt = {
    KW_IF ~ S ~ ( "let" ~ S ~ pattern ~ S ~ EQ ~ S ~ expr ~ S | expr ~ S ) ~ block ~ ( S ~ KW_ELSE ~ S ~ ( if_stmt | block ) )?
}

match_expr_stmt = {
    KW_MATCH ~ S ~ expr ~ S ~ LBRACE ~ S ~ ( match_arm ~ ( S ~ COMMA )? ~ S )* ~ RBRACE
}
match_arm = {
    pattern ~ ( S ~ KW_IF ~ S ~ expr )? ~ S ~ FATARROW ~ S ~ ( block | expr )
}

// Expressions
expr_stmt = { expr ~ WS? ~ SEMI }

expr = _{ assignment_expr }

assignment_expr = {
    pipeline_expr ~ ( S ~ ( EQ | PLUSEQ | MINUSEQ | MULEQ | IDIVEQ | DIVEQ | MODEQ | POWEQ | SHLEQ | SHREQ | ANDEQ | XOREQ | OREQ ) ~ S ~ assignment_expr )?
}

pipeline_expr = { logical_or_expr ~ ( S ~ "|>" ~ S ~ logical_or_expr )* }

logical_or_expr = { logical_and_expr ~ ( S ~ ( OROR | PIPE ) ~ S ~ logical_and_expr )* }
logical_and_expr = { equality_expr ~ ( S ~ ( ANDAND | AMP ) ~ S ~ equality_expr )* }

equality_expr = { relational_expr ~ ( WS ~ ( EQEQ | NOTEQ ) ~ WS ~ relational_expr )* }
relational_expr = { bit_or_expr ~ ( WS ~ ( LTE | GTE | LT | GT ) ~ WS ~ bit_or_expr )* }
bit_or_expr = { bit_xor_expr ~ ( WS ~ PIPE ~ WS ~ bit_xor_expr )* }
bit_xor_expr= { bit_and_expr ~ ( WS ~ CARET ~ WS ~ bit_and_expr )* }
bit_and_expr= { shift_expr ~ ( WS ~ AMP ~ WS ~ shift_expr )* }

shift_expr = { additive_expr ~ ( WS ~ ( SHL | SHR ) ~ WS ~ additive_expr )* }
additive_expr = { multiplicative_expr ~ ( WS ~ ( PLUS | MINUS ) ~ WS ~ multiplicative_expr )* }
multiplicative_expr = { power_expr ~ ( WS ~ ( STAR | IDIV | SLASH | PERCENT ) ~ WS ~ power_expr )* }
power_expr = { cast_expr ~ ( WS ~ POW ~ WS ~ power_expr )? }

cast_expr = { range_expr ~ ( S ~ KW_AS ~ S ~ ty )* }

range_expr = {
      unary_expr ~ S ~ (RANGE_EQ | RANGE_GT | RANGE_LT | RANGE) ~ S ~ unary_expr
    | RANGE_GT                  // ..>
    | RANGE_LT                  // ..<
    | RANGE_EQ                  // ..=
    | RANGE                     // ..
    | unary_expr
}

unary_expr = {
      ( INC | DEC | BANG | PLUS | MINUS | AMP | STAR | KW_AWAIT ) ~ S ~ unary_expr
    | postfix_expr
}

postfix_expr = {
    primary_expr ~ ( S ~ postfix_op )*
}
postfix_op = {
      DOT ~ S ~ ident
    | LBRACK ~ S ~ expr ~ S ~ RBRACK
    | LPAREN ~ S ~ argument_list? ~ S ~ RPAREN
    | QUESTION
    | INC
    | DEC
}

primary_expr = {
      literal
    | KW_SAFE ~ S ~ block
    | LPAREN ~ S ~ expr ~ S ~ RPAREN
    | new_expr
    | struct_lit
    | var_ref
    | template_str
    | array_lit
    | match_expr
    | if_expr
    | loop_expr
    | block
}

literal = _{
      float_lit
    | int_lit
    | str_lit
    | template_str
    | bool_lit
    | none_lit
}

new_expr = { KW_NEW ~ S ~ ident ~ S ~ LPAREN ~ S ~ argument_list? ~ S ~ RPAREN }

var_ref = { module_path }

argument_list = { expr ~ ( S? ~ COMMA ~ S? ~ expr )* }

array_lit = {
      LBRACK ~ S ~ ( expr ~ ( S ~ COMMA ~ S ~ expr )* ~ ( S ~ COMMA )? )? ~ S ~ RBRACK
    | "[]" // empty array type literal (token recognized)
}



if_expr = {
    KW_IF ~ S ~ ( "let" ~ S ~ pattern ~ S ~ EQ ~ S ~ expr ~ S | expr ~ S ) ~ block ~ ( S ~ KW_ELSE ~ S ~ ( if_expr | block ) )?
}

match_expr = {
    KW_MATCH ~ S ~ expr ~ S ~ LBRACE ~ S ~ ( match_arm ~ ( S ~ COMMA )? ~ S )* ~ RBRACE
}

loop_expr = {
    KW_LOOP ~ S ~ block
}

// Patterns
pattern = {
      enum_variant_pattern        // enum variant (must come before ident)
    | ident                       // variable (ident covers '_' and '_v' forms)
    | literal                     // literal pattern
    | array_pattern
    | struct_pattern
}

pattern_list = { pattern ~ ( S ~ COMMA ~ S ~ pattern )* }
ident_list = { ident ~ ( S ~ COMMA ~ S ~ ident )* }

enum_variant_pattern = {
    module_path ~ ( S ~ ( tuple_variant_pattern | struct_variant_pattern ) )?
}

tuple_variant_pattern = { LPAREN ~ S ~ ( pattern ~ ( S ~ COMMA ~ S ~ pattern )* )? ~ S ~ RPAREN }
struct_variant_pattern = { LBRACE ~ S ~ struct_pattern_fields? ~ S ~ RBRACE }

struct_pattern_fields = {
    struct_pattern_field ~ ( S ~ COMMA ~ S ~ struct_pattern_field )* ~ ( S ~ COMMA )?
}

struct_pattern_field = {
    ident ~ S ~ COLON ~ S ~ pattern
}

array_pattern = {
    LBRACK ~ S ~ ( pattern ~ ( S ~ COMMA ~ S ~ pattern )* )? ~ S ~ RBRACK
}

struct_pattern = {
    ident ~ S ~ LBRACE ~ S ~ ( field_pattern ~ ( S ~ COMMA ~ S ~ field_pattern )* )? ~ S ~ RBRACE
}

struct_lit = {
    ident ~ S ~ LBRACE ~ S ~ ( struct_field_init ~ ( S ~ COMMA ~ S ~ struct_field_init )* ~ ( S ~ COMMA )? )? ~ S ~ RBRACE
}

struct_field_init = {
    ident ~ S ~ COLON ~ S ~ expr
}
field_pattern = { ident ~ S ~ COLON ~ S ~ pattern }

// Types
ty = { ty_union ~ S ~ QUESTION? }
ty_union = { ty_intersection ~ ( S ~ PIPE ~ S ~ ty_intersection )* }
ty_intersection = { ty_primary ~ ( S ~ AMP ~ S ~ ty_primary )* }

ty_postfix = {
      primitive_type
    | ty_ref
    | ty_ptr
    | "weak" ~ S ~ ty
    | "dyn" ~ S ~ ty_path
    | ty_path ~ generic_args?
    | LPAREN ~ S ~ ty ~ S ~ RPAREN
}

ty_primary = {
      ty_postfix ~ ( S? ~ LBRACK ~ S? ~ RBRACK )*
    | ty_array
}

primitive_type = {
      TY_BOOL
    | TY_STRING | TY_STR
    | TY_VOID
    | TY_ANY
    | TY_U8A | TY_U8B
    | TY_U16A | TY_U16B
    | TY_U32A | TY_U32B
    | TY_U64A | TY_U64B
    | TY_I8A | TY_I8B
    | TY_I16A | TY_I16B
    | TY_I32A | TY_I32B
    | TY_I64A | TY_I64B
    | TY_F32A | TY_F32B
    | TY_F64A | TY_F64B
    | KW_RAWPTR
}

ty_array = { LBRACK ~ S ~ ty ~ ( S ~ SEMI ~ S ~ expr )? ~ S ~ RBRACK }
ty_ref   = { AMP ~ S ~ ty }
ty_ptr   = { STAR ~ S ~ ty }

ty_path = { module_path }

// Utilities


RBRACK_T = _{ RBRACK } // helper, unused but reserved
