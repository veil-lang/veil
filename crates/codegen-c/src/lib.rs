#![forbid(unsafe_code)]
#![deny(rust_2018_idioms)]
#![deny(unused_must_use)]

//! Veil Codegen-C (IR → C backend)
//!
//! This crate emits self-contained C translation units from Veil's IR.
//! It is the canonical IR→C implementation used by the CLI.
//!
//! Features:
//! - Deterministic emission order (sorted function prototypes).
//! - Basic blocks and goto-based control flow (Branch/Jump/Return).
//! - Locals (load/store), arithmetic, comparisons, select, calls.
//! - Iterator runtime hooks: safe stubs are emitted unless a runtime
//!   defines VEIL_RUNTIME_PROVIDES_ITER (see emitted C prologue).
//!
//! Public API:
//! - `CodegenConfig` minimal configuration.
//! - `IrCBackend::new`, `emit_to_string`, `write_to_path`.
//!
//! Note: This emitter is intentionally minimal and type-lenient for SSA temps;
//! it favors portability and deterministic output over aggressive C typing.

use std::fmt::Write as _;
use std::path::Path;
use veil_ir::{ProgramIR, TypeIR};

/// Code generation configuration (extend as needed).
#[derive(Debug, Clone)]
pub struct CodegenConfig {
    pub target_triple: String,
}

/// IR → C backend
/// Backend trait for IR code generators.
pub trait Backend {
    /// Emit generated code/artifact to the given path.
    fn emit(&self, ir: &ProgramIR, path: &Path) -> std::io::Result<()>;
}

#[derive(Debug, Clone)]
pub struct IrCBackend {
    pub config: CodegenConfig,
}

impl Backend for IrCBackend {
    fn emit(&self, ir: &ProgramIR, path: &Path) -> std::io::Result<()> {
        self.write_to_path(ir, path)
    }
}

impl IrCBackend {
    pub fn new(config: CodegenConfig) -> Self {
        Self { config }
    }

    /// Render IR into a self-contained C translation unit as a String.
    pub fn emit_to_string(&self, ir: &ProgramIR) -> String {
        let mut out = String::new();

        // Header
        out.push_str("/* Generated by Veil IR→C backend */\n");
        out.push_str("#include <stdint.h>\n");
        out.push_str("#include <stdbool.h>\n");
        out.push_str("#include <stddef.h>\n");
        out.push_str("#include <stdio.h>\n");
        out.push_str("#include <string.h>\n\n");

        // Iterator runtime hook stubs.
        // Tooling can provide a real runtime by defining VEIL_RUNTIME_PROVIDES_ITER
        // and supplying proper implementations with compatible signatures.
        out.push_str("/* Iterator runtime hooks (stubs)\n");
        out.push_str("   If a runtime is linked, define VEIL_RUNTIME_PROVIDES_ITER before\n");
        out.push_str("   including/compiling this TU to suppress these stubs. */\n");
        out.push_str("#ifndef VEIL_RUNTIME_PROVIDES_ITER\n");
        out.push_str("static inline bool iter_has_next(void* it) { (void)it; return false; }\n");
        out.push_str("#define iter_next(it) (0)\n");
        out.push_str("#endif\n\n");

        // Forward declare functions (sorted by name for deterministic order)
        let mut fns = ir.functions.clone();
        fns.sort_by(|a, b| a.name.cmp(&b.name));
        for f in &fns {
            let sig = self.function_signature(
                f.name.as_str(),
                &f.params.iter().map(|p| p.ty.clone()).collect::<Vec<_>>(),
                &f.ret,
            );
            out.push_str(&sig);
            out.push_str(";\n");
        }
        out.push('\n');

        // Definitions
        for f in &fns {
            let sig = self.function_signature(
                f.name.as_str(),
                &f.params.iter().map(|p| p.ty.clone()).collect::<Vec<_>>(),
                &f.ret,
            );
            out.push_str(&sig);
            out.push_str(" {\n");

            // Declare function-local slots (IR locals) deterministically
            for l in &f.locals {
                let cty = self.type_to_c(&l.ty);
                let _ = writeln!(out, "    {} l{};", cty, l.id.0);
            }

            // SSA value handling
            let mut declared: std::collections::BTreeSet<u32> = std::collections::BTreeSet::new();

            let val_ref = |id: veil_ir::ValueId| -> String {
                if (id.0 as usize) < f.params.len() {
                    format!("p{}", id.0)
                } else {
                    format!("v{}", id.0)
                }
            };

            let mut declare_or_assign =
                |id: veil_ir::ValueId, cty: &str, rhs: &str, out: &mut String| {
                    let name = if (id.0 as usize) < f.params.len() {
                        format!("p{}", id.0)
                    } else {
                        format!("v{}", id.0)
                    };
                    if declared.insert(id.0) && (id.0 as usize) >= f.params.len() {
                        let _ = writeln!(out, "    {} {} = {};", cty, name, rhs);
                    } else {
                        let _ = writeln!(out, "    {} = {};", name, rhs);
                    }
                };

            let escape_c_str = |s: &str| -> String {
                let mut out = String::with_capacity(s.len());
                let mut chars = s.chars().peekable();
                while let Some(c) = chars.next() {
                    match c {
                        // Convert actual control chars to C escapes
                        '\n' => out.push_str("\\n"),
                        '\t' => out.push_str("\\t"),
                        '\r' => out.push_str("\\r"),
                        '\"' => out.push_str("\\\""),
                        '\\' => {
                            if let Some(&next) = chars.peek() {
                                match next {
                                    // Preserve known escapes (don't double-escape)
                                    'n' | 't' | 'r' | '\\' | '\"' | '0' => {
                                        out.push('\\');
                                        out.push(next);
                                        let _ = chars.next();
                                    }
                                    _ => {
                                        // Unknown escape: escape the backslash itself
                                        out.push_str("\\\\");
                                    }
                                }
                            } else {
                                // Trailing backslash
                                out.push_str("\\\\");
                            }
                        }
                        _ => out.push(c),
                    }
                }
                out
            };

            let local_cty = |lid: veil_ir::LocalId| -> String {
                if let Some(loc) = f.locals.iter().find(|ll| ll.id == lid) {
                    self.type_to_c(&loc.ty)
                } else {
                    "int64_t".to_string()
                }
            };

            // Emit blocks in id order
            let mut blocks = f.blocks.clone();
            blocks.sort_by_key(|b| b.id);

            for b in blocks {
                let _ = writeln!(out, "bb{}:", b.id.0);

                for (i, inst) in b.insts.iter().enumerate() {
                    let res = b.results.get(i).copied().unwrap_or(veil_ir::ValueId(0));
                    match inst {
                        veil_ir::InstIR::Nop => {
                            // neutral int result for placeholder
                            declare_or_assign(res, "int64_t", "0", &mut out);
                        }
                        veil_ir::InstIR::ConstInt { value } => {
                            declare_or_assign(res, "int64_t", &format!("{}", value), &mut out);
                        }
                        veil_ir::InstIR::ConstFloat { value } => {
                            declare_or_assign(res, "double", &format!("{}", value), &mut out);
                        }
                        veil_ir::InstIR::ConstStr { value } => {
                            let esc = escape_c_str(value);
                            declare_or_assign(
                                res,
                                "const char*",
                                &format!("\"{}\"", esc),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Add { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} + {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Sub { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} - {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Mul { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} * {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Div { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} / {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        // Extended IR ops (only compiled when the feature is enabled)
                        veil_ir::InstIR::Mod { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} % {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::BitAnd { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} & {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::BitOr { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} | {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::BitXor { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} ^ {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Shl { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} << {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Shr { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("({} >> {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Not { value } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("(!{})", val_ref(*value)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Neg { value } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("(-{})", val_ref(*value)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Pos { value } => {
                            declare_or_assign(
                                res,
                                "int64_t",
                                &format!("(+{})", val_ref(*value)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Cast { value, ty } => {
                            let cty = self.type_to_c(ty);
                            declare_or_assign(
                                res,
                                &cty,
                                &format!("(({}) {})", cty, val_ref(*value)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpEq { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} == {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpNe { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} != {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpLt { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} < {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpLe { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} <= {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpGt { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} > {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::CmpGe { lhs, rhs } => {
                            declare_or_assign(
                                res,
                                "bool",
                                &format!("({} >= {})", val_ref(*lhs), val_ref(*rhs)),
                                &mut out,
                            );
                        }
                        veil_ir::InstIR::Select {
                            cond,
                            then_v,
                            else_v,
                        } => {
                            // Ternary select; default to bool type for temp
                            let expr = format!(
                                "({} ? {} : {})",
                                val_ref(*cond),
                                val_ref(*then_v),
                                val_ref(*else_v)
                            );
                            declare_or_assign(res, "bool", &expr, &mut out);
                        }
                        veil_ir::InstIR::Load { local } => {
                            let rhs = format!("l{}", local.0);
                            let cty = local_cty(*local);
                            declare_or_assign(res, &cty, &rhs, &mut out);
                        }
                        veil_ir::InstIR::Store { local, value } => {
                            let cty = local_cty(*local);
                            let _ =
                                writeln!(out, "    l{} = ({} ){};", local.0, cty, val_ref(*value));
                        }
                        veil_ir::InstIR::Call { callee, args } => {
                            // If we have a prototype among IR functions, honor its return type.
                            // Otherwise default to int64_t; for iterator hooks, macro may swallow type.
                            let mut ret_c = "int64_t".to_string();
                            for ff in &fns {
                                if ff.name == *callee {
                                    ret_c = self.type_to_c(&ff.ret);
                                    break;
                                }
                            }
                            let argv = args
                                .iter()
                                .map(|a| val_ref(*a))
                                .collect::<Vec<_>>()
                                .join(", ");
                            let call = format!("{}({})", callee, argv);

                            // Void-returning calls should be emitted as statements, not assigned.
                            if ret_c == "void" {
                                let _ = writeln!(out, "    {};", call);
                            } else {
                                // For iter_next, prefer not to commit to a concrete type if no IR proto exists.
                                // The macro (#define iter_next(it) (0)) will yield a null/zero literal.
                                declare_or_assign(res, &ret_c, &call, &mut out);
                            }
                        }
                    }
                }

                // Terminators
                match &b.term {
                    veil_ir::TerminatorIR::Return { value } => {
                        if let Some(v) = value {
                            let _ = writeln!(out, "    return {};", val_ref(*v));
                        } else if f.name == "main" {
                            // Main function should return 0 instead of void

                            let _ = writeln!(out, "    return 0;");
                        } else if f.ret != TypeIR::Void {
                            // Synthesize a default value for non-void functions that omitted an explicit return expression

                            let _ =
                                writeln!(out, "    return {};", self.default_return_expr(&f.ret));
                        } else {
                            let _ = writeln!(out, "    return;");
                        }
                    }

                    veil_ir::TerminatorIR::Branch {
                        cond,
                        then_bb,
                        else_bb,
                    } => {
                        let _ = writeln!(
                            out,
                            "    if ({}) goto bb{}; else goto bb{};",
                            val_ref(*cond),
                            then_bb.0,
                            else_bb.0
                        );
                    }

                    veil_ir::TerminatorIR::Jump { bb } => {
                        let _ = writeln!(out, "    goto bb{};", bb.0);
                    }
                }

                out.push('\n');
            }

            out.push_str("}\n\n");
        }

        out
    }

    /// Write the generated translation unit to a path (e.g., build/temp.c)
    pub fn write_to_path(&self, ir: &ProgramIR, path: &Path) -> std::io::Result<()> {
        let c_src = self.emit_to_string(ir);
        std::fs::write(path, c_src)
    }

    // ------------------------
    // Helpers
    // ------------------------

    fn function_signature(&self, name: &str, param_tys: &[TypeIR], ret: &TypeIR) -> String {
        let mut s = String::new();

        // Return type - special case main function to return int
        if name == "main" {
            s.push_str("int");
        } else {
            s.push_str(&self.type_to_c(ret));
        }
        s.push(' ');

        // Name
        s.push_str(name);
        s.push('(');

        // Parameters: name them p0, p1, ... deterministically
        for (i, ty) in param_tys.iter().enumerate() {
            if i > 0 {
                s.push_str(", ");
            }
            let cname = self.type_to_c(ty);
            let _ = write!(s, "{} p{}", cname, i);
        }

        if param_tys.is_empty() {
            s.push_str("void");
        }

        s.push(')');
        s
    }

    fn type_to_c(&self, ty: &TypeIR) -> String {
        use TypeIR::*;

        match ty {
            Void => "void".to_string(),

            I32 => "int".to_string(),

            I64 => "int64_t".to_string(),

            F32 => "float".to_string(),

            F64 => "double".to_string(),

            Bool => "bool".to_string(),

            String => "const char*".to_string(),

            Ptr(inner) => format!("{}*", self.type_to_c(inner)),

            Opaque(_name) => {
                // Use void* for now; future IR may carry canonical struct names.

                "void*".to_string()
            }
        }
    }

    /// Produce a default C literal/expression for a given IR type when a user function
    /// with non-void return type omits an explicit return value.
    fn default_return_expr(&self, ty: &TypeIR) -> &'static str {
        use TypeIR::*;
        match ty {
            Void => "",
            I32 | I64 => "0",
            F32 | F64 => "0.0",
            Bool => "false",
            String => "\"\"",
            Ptr(_) | Opaque(_) => "NULL",
        }
    }
}
